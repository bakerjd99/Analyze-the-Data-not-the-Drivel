%\input{bmamblenew.tex}

% mark up for single post 
%\input{bmpostextract.tex} %extract-single-post::

\subsection*{\href{https://analyzethedatanotthedrivel.org/2018/03/31/numpy-another-iverson-ghost/}{NumPy another Iverson Ghost}}
\addcontentsline{toc}{subsection}{NumPy another Iverson Ghost}


\noindent\emph{Posted: 31 Mar 2018 21:07:53}
\vspace{6pt}

\captionsetup[floatingfigure]{labelformat=empty}
\begin{floatingfigure}[l]{0.23\textwidth}
\centering
\includegraphics[width=0.22\textwidth]{numpy-j-logo.png}
\label{fig:5565x0}
\end{floatingfigure}During
my recent \href{https://github.com/bakerjd99/smugpyter}{SmugMug API and
Python} adventures I was haunted by an Iverson ghost:~\texttt{NumPy}

\medskip

\emph{\textbf{An Iverson ghost is an embedding of APL like array
programming features in nonAPL languages and tools.}}

\medskip

You would be surprised at how often Iverson ghosts appear. Whenever
programmers are challenged with processing large numeric arrays they
rediscover bits of APL. Often they're unaware of the rich heritage of
array processing languages but in
\texttt{NumPy\textquotesingle{}s}~case, they \emph{indirectly}
acknowledged the debt. In
\href{http://numpy.sourceforge.net/numdoc/numdoc.pdf}{\emph{Numerical
Python}} the authors wrote:


\begin{quote}
\emph{The languages which were used to guide the development of NumPy
include the infamous APL family of languages, Basis, MATLAB, FORTRAN, S
and S+, and others.}
\end{quote}


I consider ``infamous'' an upgrade from
\href{http://www.cs.virginia.edu/~evans/cs655/readings/ewd498.html}{``a
mistake carried through to perfection.''}

Not only do developers frequently conjure up Iverson ghosts, they also
invariably turn into little apostles of array programming that won't
shut up about how cutting down on all those goddamn loops clarifies and
simplifies algorithms. How learning to think about operating on entire
arrays, versus one dinky number at a time, frees the mind. Why it's
almost as if array programming
\href{http://www.jsoftware.com/papers/tot.htm}{is a tool of thought.}

Where have I heard this before?

Ahh, I've got it, when I first encountered APL almost fifty years ago.

Yes, I am an old programmer, a fossil, a living relic. My brain is a
putrid pool of punky programming languages. Python is just the latest in
a longish line of languages. Some people collect stamps. I collect
programming languages. And, just like stamp collectors have favorite
stamps, I find some programming languages more attractive than others.
For example, I recognize the undeniable utility of \texttt{C/C++}, for
many tasks they are the only serious options, yet as useful and
pervasive as \texttt{C/C++} are they have never tickled my fancy. The
notation is ugly! Yeah, I said it; suck on it C people. Similarly, the
world's most commonly used programming language \texttt{JavaScript} is
equally ugly. Again, \texttt{JavaScript} is so damn useful that
programmers put up with its many warts. Some have even made a few bucks
writing books about its
\href{http://shop.oreilly.com/product/9780596517748.do}{meager good
parts}.

I have similar inflammatory opinions about other widely used languages.
The one that is making me miserable now is \texttt{SQL}, particularly
Microsoft's variant~\texttt{T-SQL}. On purely aesthetic grounds I find
well-formed \texttt{SQL} queries less appalling than your average
\texttt{C} pointer fest. Core \texttt{SQL} is fairly elegant but the
macro programming features that have grown up around it are depraved. I
feel dirty when~forced to use them which is just about every other day.

At the end of my programming day, I want to look on something that is
beautiful. I don't particularly care about how useful a chunk of code is
or how much money it might make, or what silly little business problem
it solves. If the damn code is ugly I don't want to see it.

People keep rediscovering array programming, best described in Ken
Iverson's 1962 book
\href{http://www.jsoftware.com/papers/APL.htm}{\emph{A Programming
Language}}, for two basic reasons:

\begin{enumerate}
\itemsep1pt\parskip0pt\parsep0pt
\def\labelenumi{\arabic{enumi}.}
%\def\labelenumi{\arabic{enumi}.}
%\tightlist
\item
  It's an efficient way to handle an important class of problems.
\item
  It's a step away from the ugly and back towards the beautiful.
\end{enumerate}

Both of these reasons manifest in \texttt{NumPy}'s resounding success in
the Python world.

As usual, efficiency led the way. The authors of \emph{Numerical Python}
note:

\begin{quote}
\emph{Why are these extensions needed? The core reason is a very prosaic one,
and that is that manipulating a set of a million numbers in Python with
the standard data structures such as lists, tuples or classes is much
too slow and uses too much space.}
\end{quote}

Faced with a \href{https://www.youtube.com/watch?v=ZBAijg5Betw}{``does
not compute''} situation you can either try something else or fix what
you have. The Python people fixed Python with \texttt{NumPy}.
\href{https://www.quora.com/Whats-the-exact-difference-between-a-Pythoneer-and-a-Pythonista}{Pythonistas}
reluctantly embraced \texttt{NumPy} but quickly went \emph{apostolic!}
Now books like
\href{http://shop.oreilly.com/product/0636920038481.do}{\emph{Elegant
SciPy}} and the entire \texttt{SciPy} toolset that been built on
\texttt{NumPy} take it for granted.

Is there anything in \texttt{NumPy} for programmers that have been
drinking the array processing cool aid for decades? The answer is yes!
\href{http://code.jsoftware.com/wiki/NuVoc}{J programmers}, in
particular, are in for a treat with the new Python3 addon that's been
released with the latest J 8.07 beta. This addon directly supports
\texttt{NumPy} arrays making it easy to swap data in and out of the
J/Python environments. It's one of those best of both worlds things.

The following \texttt{NumPy} examples are from the \texttt{SciPy.org}
\href{https://docs.scipy.org/doc/numpy-dev/user/quickstart.html}{NumPy
quick start tutorial}. For each \texttt{NumPy} statement, I have
provided a J equivalent. J is a descendant of APL. It was largely
designed by the same man: Ken Iverson. A scumbag lawyer or greedy patent
troll might consider suing \texttt{NumPy}'s creators after looking at
these examples. APL's influence is obvious. Fortunately, Ken Iverson was
more interested in promoting good ideas that profiting from them. I
suspect he would be flattered that APL has mutated and colonized strange
new worlds and I think even zealous Pythonistas will agree that Python
is a delightfully strange world.

\subsection*{\texorpdfstring{Some \texttt{Numpy} and J
examples}{Some Numpy and J examples}}

Selected Examples from
\url{https://docs.scipy.org/doc/numpy-dev/user/quickstart.html} Output
has been suppressed here. For a more detailed look at these examples
browse the Jupyter notebook:~
\href{https://github.com/bakerjd99/jacks/blob/master/numpyjlove/NumPy\%20and\%20J\%20make\%20Sweet\%20Array\%20Love.ipynb}{NumPy
and J Make Sweet Array Love}.

% The following alternating code blocks are a worst case for lstlisting.
% Rendering two programming languages requires splitting these examples
% into a series of Python and J code blocks.  This is way to much
% work right now.  I will have to look at better ways of doing 
% this in the future.  

\subsection*{Creating simple arrays}

\begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy
  a = np.arange(15).reshape(3, 5)
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J 
  a =. 3 5 $ i. 15
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  a = np.array([2,3,4])
\end{lstlisting} 

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]    
  NB. J 
  a =. 2 3 4 
\end{lstlisting} 

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  b = np.array([(1.5,2,3), (4,5,6)])
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]    
  NB. J 
  b =. 1.5 2 3 ,: 4 5 6
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  c = np.array( [ [1,2], [3,4] ], dtype=complex ) 
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]   
  NB. J 
  0 j.~ 1 2 ,: 3 4  
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - make complex numbers with nonzero real and imaginary parts
  c + (0+4.7j) 
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]   
  NB. J - also for J
  c + 0j4.7
\end{lstlisting}
 
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  # numpy 
  np.zeros( (3,4) ) 
\end{lstlisting} 

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]  
  NB. J 
  3 4 $ 0  
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  # numpy - allocates array with whatever is in memory 
  np.empty( (2,3) )  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]   
  NB. J - uses fill - safer but slower than numpy's trust memory method 
  2 3 $ 0.0001 
\end{lstlisting}
\end{tcolorbox}

\subsection*{Basic operations}

\begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  a = np.array( [20,30,40,50] ) 
  b = np.arange( 4 ) 
  c = a - b  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]   
  NB. J 
  a =. 20 30 40 50 
  b =. i. 4 
  c =. a - b  
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  # numpy - uses previously defined (b) 
  b ** 2  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]  
  NB. J 
  b ^ 2
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - uses previously defined (a) 
  10 * np.sin(a)  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]  
  NB. J 
  10 * 1 o. a  
\end{lstlisting}
  
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - booleans are True and False 
  a < 35  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J - booleans are 1 and 0 
  a < 35
\end{lstlisting}
\end{tcolorbox}

\subsection*{Array processing}

\begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  a = np.array( [[1,1], [0,1]] ) 
  b = np.array( [[2,0], [3,4]] ) 
  # elementwise product 
  a * b
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J 
  a =. 1 1 ,: 0 1 
  b =. 2 0 ,: 3 4 
  a * b
\end{lstlisting}

\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - matrix product 
  np.dot(a, b)
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J - matrix product 
  a +/ . * b   
\end{lstlisting} 
  
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - uniform pseudo random 
  a = np.random.random( (2,3) )  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]   
  NB. J - uniform pseudo random 
  a =. ? 2 3 $ 0  
\end{lstlisting}
  
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy - sum all array elements - implicit ravel 
  a.sum(a)  
\end{lstlisting}

\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]  
  NB. J - sum all array elements - explicit ravel 
  +/ , a  
\end{lstlisting}
 
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy 
  b = np.arange(12).reshape(3,4) 
  # sum of each column 
  b.sum(axis=0) 
  # min of each row 
  b.min(axis=1) 
  # cumulative sum along each row 
  b.cumsum(axis=1) 
  # transpose 
  b.T     
\end{lstlisting}

\lstset{escapeinside={(}{)}} % | characater does not show in lstlisting without escape
\begin{lstlisting}[language=jdoc, escapeinside={(}{)}, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J  
  b =. 3 4 $ i. 12 
  NB. sum of each column 
  +/ b 
  NB. min of each row 
  <./"1 b 
  NB. cumulative sum along each row 
  +/\"0 1 b 
  NB. transpose 
  (\verb!|!): b
\end{lstlisting}
\end{tcolorbox}
\lstset{escapeinside={}{}} 


\subsection*{Indexing and slicing}

\begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\begin{lstlisting}[language=python, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize]
  # numpy  
  a = np.arange(10) ** 3  
  a[2] 
  a[2:5] 
  a[ : :-1]   # reversal
\end{lstlisting}

\lstset{escapeinside={[}{]}}
\begin{lstlisting}[language=jdoc, frame=single, framerule=0pt, basicstyle=\ttfamily\normalsize, keywordstyle=\bfseries\color{keywcolor}\normalsize] 
  NB. J 
  a =. (i. 10) ^ 3 
  2 { a 
  (2 + i. 3) { a
  [\verb!|!]. a
\end{lstlisting}
\end{tcolorbox}
\lstset{escapeinside={}{}} 



%\end{document} %extract-single-post::
 